# The entry format is (cudaname, julianame, kernelcode)
# With single name entries cudaname=julianame and kernelcode=name(xi,yi).
# I commented out functions if I don't know the Julia equivalent.

binary_ops = [
    ("add","+","xi+yi","__hadd(xi,yi)"),
    ("sub","-","xi-yi","__hsub(xi,yi)"),
    ("mul","*","xi*yi","__hmul(xi,yi)"),
    ("div","/","xi/yi","__hdiv(xi,yi)"),
    ("pow","^","pow(xi,yi)","hpow(xi,yi)"),
    ("max","max","(xi>yi?xi:yi)","(__hgt(xi,yi)?xi:yi)"),
    ("min","min","(xi<yi?xi:yi)","(__hlt(xi,yi)?xi:yi)"),
    ("eq","==","xi==yi","__heq(xi,yi)"),
    ("ne","!=","xi!=yi","__hne(xi,yi)"),
    ("gt",">","xi>yi","__hgt(xi,yi)"),
    ("ge",">=","xi>=yi","__hge(xi,yi)"),
    ("lt","<","xi<yi","__hlt(xi,yi)"),
    ("le","<=","xi<=yi","__hle(xi,yi)"),
    # "hypot",
    # "rhypot",
    # "atan2",
    # "frexp",
    # "ldexp",
    # "scalbn",
    # "scalbln",
    # "jn",
    # "yn",
    # "fmod",
    # "remainder",
    # "mod",
    # "fdim",
    ("invxback","invxback","(-xi*yi*yi)","__hneg(__hmul(xi,__hmul(yi,yi)))"),
    ("reluback","reluback","(yi>0?xi:0)","(__hgt(yi,0)?xi:0)"),
    ("eluback","eluback","(yi>0?xi:xi*(1+yi))","(__hgt(yi,0)?xi:__hmul(xi,__hadd(yi,1)))"),
    ("seluback","seluback","(yi>0?1.0507009873554805*xi:xi*(1.7580993408473773+yi))","(__hgt(yi,0)?__hmul(xi,1.0507009873554805):__hmul(xi,__hadd(yi,1.7580993408473773)))"),
    ("sigmback","sigmback","(xi*yi*(1-yi))","__hmul(xi,__hmul(yi,__hsub(1,yi)))"),
    ("tanhback","tanhback","(xi*(1-yi*yi))","__hmul(xi,__hsub(1,__hmul(yi,yi)))"),
    # ("rpow","rpow","pow(yi,xi)"),   # need this for Array.^Scalar -> cuda bug #108 switching to CuArrays for pow
]

# The following list comes from the NVIDIA math docs with some extras.
# http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#mathematical-functions-appendix
# The entry format is (cudaname, julianame, kernelcode)
# With single name entries cudaname=julianame and kernelcode=name(xi).
# I commented out functions if I don't know the Julia equivalent.
unary_ops = [
("abs2", "abs2", "(xi*xi)"),
("abs", "abs", "(xi<0?-xi:xi)"),
"acos",
"acosh",
"asin",
"asinh",
"atan",
"atanh",
"cbrt",
"ceil",
"cos",
"cosh",
"cospi",
# "cyl_bessel_i0",
# "cyl_bessel_i1",
"erf",
"erfc",
"erfcinv",
"erfcx",
"erfinv",
"exp",
"exp10",
"exp2",
"expm1",
"floor",
# "ilogb",
("invx", "invx", "1/xi"),
# "j0",
# "j1",
("gamma_impl", "gamma"),
("lgamma", "lgamma"), # TODO: SpecialFunctions 0.8: lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead. Other alternative is loggamma, throws a DomainError if gamma(x) is negative.
("digamma_impl", "digamma"),
("trigamma_impl", "trigamma"),
#
# "llrint",
# "llround",
"log",
"log10",
"log1p",
"log2",
# "logb",
# "lrint",
# "lround",
# "nearbyint",
("neg", "-", "-xi"),
# "normcdf",
# "normcdfinv",
("one", "one", "1"),
# "rcbrt",
("relu", "relu", "(xi>0?xi:0)"),
("elu", "elu", "(xi>0?xi:exp(xi)-1)"),
("selu", "selu", "1.0507009873554805*(xi>0?xi:1.6732632423543778*(exp(xi)-1))"),
# "rint",
"round",
# "rsqrt",
("sigm", "sigm", "(xi>=0?1/(1+exp(-xi)):(exp(xi)/(1+exp(xi))))"),
("sign", "sign", "(xi>0?1:xi<0?-1:0)"),
"sin",
"sinh",
"sinpi",
"sqrt",
"tan",
"tanh",
# "tgamma",
"trunc",
# "y0",
# "y1",
("zero", "zero", "0"),
]

reduction_ops = [
# The entry format is (cudaname, julianame, merge, item, init)
# ai is the accumulator, xi is the array element
("sum","sum","ai+xi","xi","0"),
("prod","prod","ai*xi","xi","1"),
("maximum","maximum","(ai>xi ? ai : xi)","xi","(-INFINITY)"),
("minimum","minimum","(ai<xi ? ai : xi)","xi","INFINITY"),
("sumabs","sumabs","ai+xi","(xi<0 ? -xi : xi)","0"),
("sumabs2","sumabs2","ai+xi","(xi*xi)","0"),
("maxabs","maxabs","(ai>xi ? ai : xi)","(xi<0 ? -xi : xi)","0"),
("minabs","minabs","(ai<xi ? ai : xi)","(xi<0 ? -xi : xi)","INFINITY"),
("countnz","countnz","ai+xi","(xi!=0)","0"),
]
